//! Trace query CLI tool for analyzing emulator execution traces
//!
//! This tool provides a simple query interface for searching and analyzing
//! trace files generated by the test runner.

use anyhow::{Context, Result};
use ceres_test_runner::trace_index::{IndexStats, TraceIndex};
use clap::{Parser, Subcommand};
use std::path::{Path, PathBuf};

#[derive(Parser)]
#[command(name = "trace-query")]
#[command(about = "Query and analyze emulator execution traces", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Build an index for a trace file
    Index {
        /// Path to the trace file (JSONL format)
        #[arg(short, long)]
        trace: PathBuf,

        /// Checkpoint interval (number of instructions between checkpoints)
        #[arg(short, long, default_value_t = 1000)]
        interval: usize,

        /// Output path for the index file
        #[arg(short, long)]
        output: Option<PathBuf>,
    },

    /// Query a trace file using an index
    Query {
        /// Path to the trace file
        #[arg(short, long)]
        trace: PathBuf,

        /// Path to the index file (auto-detected if not provided)
        #[arg(short, long)]
        index: Option<PathBuf>,

        /// Query expression (e.g., "pc:0x100", "instruction:LD A, B")
        query: String,

        /// Maximum results to return
        #[arg(short = 'n', long, default_value_t = 10)]
        max_results: usize,
    },

    /// Show statistics about a trace
    Stats {
        /// Path to the trace file or index file
        path: PathBuf,
    },

    /// Find a specific PC value
    FindPc {
        /// Path to the trace file
        #[arg(short, long)]
        trace: PathBuf,

        /// Path to the index file (auto-detected if not provided)
        #[arg(short, long)]
        index: Option<PathBuf>,

        /// PC value to find (hex format, e.g., 0x100)
        pc: String,
    },

    /// Find a specific instruction
    FindInstruction {
        /// Path to the trace file
        #[arg(short, long)]
        trace: PathBuf,

        /// Path to the index file (auto-detected if not provided)
        #[arg(short, long)]
        index: Option<PathBuf>,

        /// Instruction to find (e.g., "LD A, B" or "JR NZ")
        instruction: String,

        /// Show context lines around matches
        #[arg(short, long, default_value_t = 2)]
        context: usize,
    },

    /// Extract entries at specific line numbers
    Extract {
        /// Path to the trace file
        #[arg(short, long)]
        trace: PathBuf,

        /// Line numbers to extract (comma-separated or range, e.g., "10,20,30" or "10-20")
        lines: String,
    },
}

#[expect(clippy::too_many_lines)]
fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Index {
            trace,
            interval,
            output,
        } => {
            println!("Building index for {}...", trace.display());
            let index = TraceIndex::build_from_jsonl(&trace, interval)
                .context("Failed to build trace index")?;

            let stats = index.stats();
            print_stats(&stats);

            let output_path = output.unwrap_or_else(|| {
                let mut p = trace.clone();
                p.set_extension("index.json");
                p
            });

            index
                .export(&output_path)
                .context("Failed to export index")?;
            println!("\nIndex saved to: {}", output_path.display());
        }

        Commands::Query {
            trace,
            index,
            query,
            max_results,
        } => {
            let index_path = index.unwrap_or_else(|| auto_detect_index(&trace));
            let index = TraceIndex::load(&index_path).context("Failed to load index")?;

            println!("Querying trace: {}", trace.display());
            println!("Using index: {}", index_path.display());
            println!("Query: {query}\n");

            // Parse query (simple format: "field:value")
            if let Some((field, value)) = query.split_once(':') {
                match field {
                    "pc" => {
                        let pc = parse_hex_u16(value)?;
                        if let Some(pc_index) = index.find_pc(pc) {
                            println!("Found {} occurrences of PC={:#06X}", pc_index.count, pc);
                            print_line_ranges(&pc_index.line_ranges, max_results);
                        } else {
                            println!("PC={pc:#06X} not found in trace");
                        }
                    }
                    "instruction" | "inst" => {
                        if let Some(inst_index) = index.find_instruction(value) {
                            println!(
                                "Found {} occurrences of '{}'",
                                inst_index.count, inst_index.instruction
                            );
                            print_line_ranges(&inst_index.line_ranges, max_results);
                        } else {
                            println!("Instruction '{value}' not found in trace");
                        }
                    }
                    _ => {
                        anyhow::bail!("Unknown field: {field}. Supported: pc, instruction");
                    }
                }
            } else {
                anyhow::bail!("Invalid query format. Use 'field:value' (e.g., 'pc:0x100')");
            }
        }

        Commands::Stats { path } => {
            // Try loading as index first, then as trace
            let stats = if path.extension().and_then(|s| s.to_str()) == Some("json") {
                let index = TraceIndex::load(&path).context("Failed to load index")?;
                index.stats()
            } else {
                let index = TraceIndex::build_from_jsonl(&path, 1000)
                    .context("Failed to build index from trace")?;
                index.stats()
            };

            print_stats(&stats);
        }

        Commands::FindPc { trace, index, pc } => {
            let index_path = index.unwrap_or_else(|| auto_detect_index(&trace));
            let index = TraceIndex::load(&index_path).context("Failed to load index")?;

            let pc_val = parse_hex_u16(&pc)?;
            if let Some(pc_index) = index.find_pc(pc_val) {
                println!(
                    "Found {} occurrences of PC={:#06X}\n",
                    pc_index.count, pc_val
                );
                print_line_ranges(&pc_index.line_ranges, 100);

                // Show a few example entries
                println!("\nShowing first few entries:");
                show_trace_lines(&trace, &pc_index.line_ranges, 3)?;
            } else {
                println!("PC={pc_val:#06X} not found in trace");
            }
        }

        Commands::FindInstruction {
            trace,
            index,
            instruction,
            context,
        } => {
            let index_path = index.unwrap_or_else(|| auto_detect_index(&trace));
            let index = TraceIndex::load(&index_path).context("Failed to load index")?;

            if let Some(inst_index) = index.find_instruction(&instruction) {
                println!(
                    "Found {} occurrences of '{}'\n",
                    inst_index.count, inst_index.instruction
                );
                print_line_ranges(&inst_index.line_ranges, 100);

                // Show examples with context
                println!("\nShowing first few entries with {context} lines of context:");
                show_trace_lines_with_context(&trace, &inst_index.line_ranges, 3, context)?;
            } else {
                println!("Instruction '{instruction}' not found in trace");
            }
        }

        Commands::Extract { trace, lines } => {
            let line_numbers = parse_line_spec(&lines)?;
            extract_lines(&trace, &line_numbers)?;
        }
    }

    Ok(())
}

fn print_stats(stats: &IndexStats) {
    println!("Trace Statistics:");
    println!("  Total entries:        {}", stats.total_entries);
    println!("  Unique PCs:           {}", stats.unique_pcs);
    println!("  Unique instructions:  {}", stats.unique_instructions);
    println!("  Checkpoints:          {}", stats.checkpoint_count);
    println!("  Memory addresses:     {}", stats.memory_addresses);
}

fn print_line_ranges(ranges: &[ceres_test_runner::trace_index::LineRange], max_ranges: usize) {
    let display_ranges = if ranges.len() > max_ranges {
        println!(
            "Line ranges (showing first {} of {}):",
            max_ranges,
            ranges.len()
        );
        &ranges[..max_ranges]
    } else {
        println!("Line ranges:");
        ranges
    };

    for range in display_ranges {
        if range.end - range.start == 1 {
            println!("  Line {}", range.start);
        } else {
            println!(
                "  Lines {}-{} ({} entries)",
                range.start,
                range.end - 1,
                range.end - range.start
            );
        }
    }

    if ranges.len() > max_ranges {
        println!("  ... and {} more ranges", ranges.len() - max_ranges);
    }
}

fn show_trace_lines(
    trace_path: &PathBuf,
    ranges: &[ceres_test_runner::trace_index::LineRange],
    max_ranges: usize,
) -> Result<()> {
    use std::io::{BufRead, BufReader};

    let file = std::fs::File::open(trace_path)?;
    let reader = BufReader::new(file);
    let lines: Vec<String> = reader.lines().collect::<std::io::Result<_>>()?;

    for (i, range) in ranges.iter().take(max_ranges).enumerate() {
        if i > 0 {
            println!();
        }
        for line_num in range.start..range.end.min(range.start + 3) {
            if line_num < lines.len() {
                let entry: serde_json::Value = serde_json::from_str(&lines[line_num])?;
                println!("  [{}] {}", line_num, format_trace_entry(&entry));
            }
        }
        if range.end - range.start > 3 {
            println!("  ... ({} more)", range.end - range.start - 3);
        }
    }

    Ok(())
}

fn show_trace_lines_with_context(
    trace_path: &PathBuf,
    ranges: &[ceres_test_runner::trace_index::LineRange],
    max_ranges: usize,
    context: usize,
) -> Result<()> {
    use std::io::{BufRead, BufReader};

    let file = std::fs::File::open(trace_path)?;
    let reader = BufReader::new(file);
    let lines: Vec<String> = reader.lines().collect::<std::io::Result<_>>()?;

    for (i, range) in ranges.iter().take(max_ranges).enumerate() {
        if i > 0 {
            println!("\n{}", "-".repeat(60));
        }

        let start_with_context = range.start.saturating_sub(context);
        let end_with_context = (range.end + context).min(lines.len());

        for line_num in start_with_context..end_with_context {
            if line_num < lines.len() {
                let entry: serde_json::Value = serde_json::from_str(&lines[line_num])?;
                let marker = if line_num >= range.start && line_num < range.end {
                    ">>>"
                } else {
                    "   "
                };
                println!("{} [{}] {}", marker, line_num, format_trace_entry(&entry));
            }
        }
    }

    Ok(())
}

fn format_trace_entry(entry: &serde_json::Value) -> String {
    let pc = entry
        .get("pc")
        .and_then(serde_json::Value::as_u64)
        .unwrap_or(0);
    let instruction = entry
        .get("instruction")
        .and_then(|v| v.as_str())
        .unwrap_or("???");
    let a = entry
        .get("a")
        .and_then(serde_json::Value::as_u64)
        .unwrap_or(0);
    let f = entry
        .get("f")
        .and_then(serde_json::Value::as_u64)
        .unwrap_or(0);

    format!("PC={pc:#06X} {instruction:20} A={a:#04X} F={f:#04X}")
}

fn extract_lines(trace_path: &PathBuf, line_numbers: &[usize]) -> Result<()> {
    use std::io::{BufRead, BufReader};

    let file = std::fs::File::open(trace_path)?;
    let reader = BufReader::new(file);
    let lines: Vec<String> = reader.lines().collect::<std::io::Result<_>>()?;

    for &line_num in line_numbers {
        if line_num < lines.len() {
            let entry: serde_json::Value = serde_json::from_str(&lines[line_num])?;
            println!("[{}] {}", line_num, format_trace_entry(&entry));
        } else {
            eprintln!(
                "Warning: Line {} is out of range (trace has {} lines)",
                line_num,
                lines.len()
            );
        }
    }

    Ok(())
}

fn parse_line_spec(spec: &str) -> Result<Vec<usize>> {
    let mut lines = Vec::new();

    for part in spec.split(',') {
        let part = part.trim();
        if let Some((start, end)) = part.split_once('-') {
            let start: usize = start.trim().parse()?;
            let end: usize = end.trim().parse()?;
            lines.extend(start..=end);
        } else {
            lines.push(part.parse()?);
        }
    }

    lines.sort_unstable();
    lines.dedup();
    Ok(lines)
}

fn parse_hex_u16(s: &str) -> Result<u16> {
    let s = s.trim().trim_start_matches("0x").trim_start_matches("0X");
    u16::from_str_radix(s, 16).context("Invalid hex number")
}

fn auto_detect_index(trace_path: &Path) -> PathBuf {
    let mut index_path = trace_path.to_path_buf();
    index_path.set_extension("index.json");
    index_path
}
